import requests
import pandas as pd
from typing import Dict, List, Optional
from io import StringIO
from dataclasses import dataclass
from datetime import datetime
import numpy as np
import matplotlib.pyplot as plt
import itertools


@dataclass
class SimulationRun:
    """Class to store results of a single simulation run"""
    run_id: int
    config: Dict
    final_status: str
    years_survived: int
    final_population: int
    final_resources: float
    final_health: float
    distance_covered: float
    disease_outbreaks: int
    overcrowding_events: int
    critical_rationing_events: int
    normal_rationing_events: int

class EnhancedGenerationShipClient:
    def __init__(self, base_url: str = 'http://localhost:5001'):
        self.base_url = base_url.rstrip('/')
        self.simulation_runs: List[SimulationRun] = []
        
    def run_multiple_simulations(self, config: Dict, num_runs: int = 10, max_years: int = 1000) -> None:
        """
        Run multiple simulations with the same configuration and store results
        
        Args:
            config: Simulation configuration dictionary
            num_runs: Number of simulation runs to perform
            max_years: Maximum number of years to simulate per run
        """
        self.simulation_runs = [] 
        for run_id in range(num_runs):
            print(f"Starting simulation run {run_id + 1}/{num_runs}")
            
            # Initialize new simulation
            self.initialize(config)
            
            # Track events for this run
            disease_outbreaks = 0
            overcrowding_events = 0
            critical_rationing_events = 0
            normal_rationing_events = 0
            
            # Run simulation year by year until completion or max_years
            final_status = None
            years_survived = 0
            final_population = 0
            final_resources = 0
            final_health = 0
            distance_covered = 0
            
            for year in range(max_years):
                results = self.simulate(years=1)
                if not results:  # Empty results means simulation failed
                    break
                    
                last_year = results[-1]
                
                # Update event counters
                if last_year.get('diseaseOutbreakEvent', 0):
                    disease_outbreaks += 1
                if last_year.get('overCrowdingEvent', 0):
                    overcrowding_events += 1
                if last_year.get('criticalRationingEvent', 0):
                    critical_rationing_events += 1
                if last_year.get('normalRationingEvent', 0):
                    normal_rationing_events += 1
                
                # Update final statistics
                final_status = last_year['status']
                years_survived = year + 1
                final_population = last_year['population']
                final_resources = last_year['resources']
                final_health = last_year['health_index']
                distance_covered = last_year['distance_covered']
                
                if final_status in ['Success', 'Failed']:
                    break
            
            # Store run results
            run_result = SimulationRun(
                run_id=run_id,
                config=config.copy(),
                final_status=final_status,
                years_survived=years_survived,
                final_population=final_population,
                final_resources=final_resources,
                final_health=final_health,
                distance_covered=distance_covered,
                disease_outbreaks=disease_outbreaks,
                overcrowding_events=overcrowding_events,
                critical_rationing_events=critical_rationing_events,
                normal_rationing_events=normal_rationing_events
            )
            self.simulation_runs.append(run_result)
            
            # Reset simulation for next run
            self.reset()

    def generate_summary_report(self, filename: str = None) -> pd.DataFrame:
        """
        Generate a summary report of all simulation runs
        
        Args:
            filename: Optional filename to save the report (CSV or XLSX)
            
        Returns:
            DataFrame containing the summary report
        """
        if not self.simulation_runs:
            raise ValueError("No simulation runs to summarize")
            
        # Convert simulation runs to DataFrame
        runs_data = []
        for run in self.simulation_runs:
            run_dict = {
                'Run ID': run.run_id,
                'Final Status': run.final_status,
                'Years Survived': run.years_survived,
                'Final Population': run.final_population,
                'Final Resources': run.final_resources,
                'Final Health': run.final_health,
                'Distance Covered (km)': run.distance_covered,
                'Disease Outbreaks': run.disease_outbreaks,
                'Overcrowding Events': run.overcrowding_events,
                'Critical Rationing Events': run.critical_rationing_events,
                'Normal Rationing Events': run.normal_rationing_events,
            }
            # Add configuration parameters
            for key, value in run.config.items():
                run_dict[f'Config_{key}'] = value
            runs_data.append(run_dict)
            
        df = pd.DataFrame(runs_data)
        
        # Add summary statistics
        summary_stats = pd.DataFrame({
            'Metric': [
                'Success Rate',
                'Average Years Survived',
                'Average Final Population',
                'Average Final Resources',
                'Average Final Health',
                'Average Distance Covered',
                'Average Disease Outbreaks',
                'Average Overcrowding Events',
                'Average Critical Rationing Events',
                'Average Normal Rationing Events'
            ],
            'Value': [
                f"{(df['Final Status'] == 'Success').mean() * 100:.1f}%",
                f"{df['Years Survived'].mean():.1f}",
                f"{df['Final Population'].mean():.1f}",
                f"{df['Final Resources'].mean():.1f}",
                f"{df['Final Health'].mean():.1f}",
                f"{df['Distance Covered (km)'].mean():.1f}",
                f"{df['Disease Outbreaks'].mean():.1f}",
                f"{df['Overcrowding Events'].mean():.1f}",
                f"{df['Critical Rationing Events'].mean():.1f}",
                f"{df['Normal Rationing Events'].mean():.1f}"
            ]
        })
        
        # Save to file if filename provided
        if filename:
            if filename.endswith('.xlsx'):
                with pd.ExcelWriter(filename) as writer:
                    df.to_excel(writer, sheet_name='Detailed Results', index=False)
                    summary_stats.to_excel(writer, sheet_name='Summary Statistics', index=False)
            else:  # Save as CSV
                df.to_csv(filename, index=False)
                
        return df, summary_stats

    # Include existing methods from GenerationShipClient
    def initialize(self, config: Dict) -> Dict:
        required_params = {
            'initial_population',
            'ship_capacity',
            'initial_resources',
            'birth_rate',
            'death_rate',
            'resource_gen_rate',
            'lightspeed_fraction',
            'health_index'
        }

        missing_params = required_params - set(config.keys())
        if missing_params:
            raise ValueError(f"Missing required parameters: {', '.join(missing_params)}")

        response = requests.post(f"{self.base_url}/initialize", json=config)
        response.raise_for_status()
        return response.json()

    def simulate(self, years: int = 1) -> List[Dict]:
        response = requests.post(f"{self.base_url}/simulate", json={'years': years})
        response.raise_for_status()
        return response.json()

    def reset(self) -> Dict:
        response = requests.post(f"{self.base_url}/reset")
        response.raise_for_status()
        return response.json()

# Generation Ship Configurations Tuned to Server Mechanics

class DetailedSimulationClient(EnhancedGenerationShipClient):
    def run_detailed_simulation(self, config: Dict, num_runs: int = 10, max_years: int = 1000,
                              detail_years: int = 10) -> None:
        """
        Run simulations with detailed monitoring of early years
        
        Args:
            config: Simulation configuration
            num_runs: Number of simulation runs
            max_years: Maximum simulation years
            detail_years: Number of years to track in detail
        """
        self.simulation_runs = []
        early_year_data = []
        
        for run_id in range(num_runs):
            print(f"\nStarting simulation run {run_id + 1}/{num_runs}")
            self.initialize(config)
            
            # Track events
            disease_outbreaks = 0
            overcrowding_events = 0
            critical_rationing_events = 0
            normal_rationing_events = 0
            
            # Track detailed early years
            yearly_data = []
            
            for year in range(max_years):
                results = self.simulate(years=1)
                if not results:
                    break
                    
                last_year = results[-1]
                
                # Update event counters
                if last_year.get('diseaseOutbreakEvent', 0):
                    disease_outbreaks += 1
                if last_year.get('overCrowdingEvent', 0):
                    overcrowding_events += 1
                if last_year.get('criticalRationingEvent', 0):
                    critical_rationing_events += 1
                if last_year.get('normalRationingEvent', 0):
                    normal_rationing_events += 1
                
                # Store detailed data for early years
                if year < detail_years:
                    yearly_data.append({
                        'run_id': run_id,
                        'year': year,
                        'population': last_year['population'],
                        'resources': last_year['resources'],
                        'health_index': last_year['health_index'],
                        'resource_gen_rate': last_year['resource_gen_rate'],
                        'disease_outbreak': last_year.get('diseaseOutbreakEvent', 0),
                        'overcrowding': last_year.get('overCrowdingEvent', 0),
                        'critical_rationing': last_year.get('criticalRationingEvent', 0),
                        'normal_rationing': last_year.get('normalRationingEvent', 0)
                    })
                
                # Update final statistics
                final_status = last_year['status']
                years_survived = year + 1
                final_population = last_year['population']
                final_resources = last_year['resources']
                final_health = last_year['health_index']
                distance_covered = last_year['distance_covered']
                
                if final_status in ['Success', 'Failed']:
                    break
            
            # Store run results (keeping existing logic)
            run_result = SimulationRun(
                run_id=run_id,
                config=config.copy(),
                final_status=final_status,
                years_survived=years_survived,
                final_population=final_population,
                final_resources=final_resources,
                final_health=final_health,
                distance_covered=distance_covered,
                disease_outbreaks=disease_outbreaks,
                overcrowding_events=overcrowding_events,
                critical_rationing_events=critical_rationing_events,
                normal_rationing_events=normal_rationing_events
            )
            self.simulation_runs.append(run_result)
            early_year_data.extend(yearly_data)
            
            self.reset()
            
        # Convert early year data to DataFrame for analysis
        early_df = pd.DataFrame(early_year_data)
        return early_df

    def analyze_early_years(self, early_df: pd.DataFrame) -> None:
        """Analyze and print statistics about early years"""
        print("\nEarly Years Analysis:")
        print("-" * 50)
        
        # Analyze each year
        for year in early_df['year'].unique():
            year_data = early_df[early_df['year'] == year]
            print(f"\nYear {year}:")
            print(f"Average Population: {year_data['population'].mean():.1f}")
            print(f"Average Resources: {year_data['resources'].mean():.1f}")
            print(f"Average Health: {year_data['health_index'].mean():.1f}")
            print(f"Disease Outbreaks: {year_data['disease_outbreak'].sum()}")
            print(f"Overcrowding Events: {year_data['overcrowding'].sum()}")
            print(f"Critical Rationing Events: {year_data['critical_rationing'].sum()}")
            
        # Calculate survival statistics
        survival_data = early_df.groupby('run_id')['year'].max()
        print("\nSurvival Statistics:")
        print(f"Runs ending in first {len(early_df['year'].unique())} years: "
              f"{(survival_data < early_df['year'].max()).mean() * 100:.1f}%")
        

class StabilityAnalysisClient(EnhancedGenerationShipClient):
    def analyze_stability(self, config: Dict, num_runs: int = 100) -> Dict:
        """
        Analyze the stability of simulation outcomes for a given configuration.
        
        Args:
            config: Simulation configuration dictionary
            num_runs: Number of simulation runs to perform
            
        Returns:
            Dictionary containing variance analysis of key metrics
        """
        # Run simulations
        self.run_multiple_simulations(config, num_runs=num_runs)
        
        # Extract key metrics for analysis
        metrics = {
            'years_survived': [],
            'final_population': [],
            'final_resources': [],
            'final_health': [],
            'distance_covered': [],
            'success_rate': []
        }
        
        # Calculate success rate for each 10% of runs
        batch_size = max(num_runs // 10, 1)
        for i in range(0, num_runs, batch_size):
            batch = self.simulation_runs[i:i+batch_size]
            success_rate = sum(1 for run in batch if run.final_status == "Success") / len(batch)
            metrics['success_rate'].append(success_rate)
        
        # Collect other metrics
        for run in self.simulation_runs:
            metrics['years_survived'].append(run.years_survived)
            metrics['final_population'].append(run.final_population)
            metrics['final_resources'].append(run.final_resources)
            metrics['final_health'].append(run.final_health)
            metrics['distance_covered'].append(run.distance_covered)
                
        analysis = {
            'success_rate': {
                'mean': np.mean(metrics['success_rate']),
                'variance': np.var(metrics['success_rate']),
                'std': np.std(metrics['success_rate'])
            }
        }
        
        for metric in ['years_survived', 'final_population', 'final_resources', 
                      'final_health', 'distance_covered']:
            analysis[metric] = {
                'mean': np.mean(metrics[metric]),
                'variance': np.var(metrics[metric]),
                'std': np.std(metrics[metric]),
                'coefficient_of_variation': np.std(metrics[metric]) / np.mean(metrics[metric])
                if np.mean(metrics[metric]) != 0 else float('inf')
            }
            
        # Calculate stability score (lower means more stable)
        # Weighted average of coefficient of variation for key metrics
        weights = {
            'success_rate': 0.3,
            'years_survived': 0.2,
            'final_population': 0.2,
            'final_resources': 0.15,
            'final_health': 0.15
        }
        
        stability_components = []
        for metric, weight in weights.items():
            if metric == 'success_rate':
                # For success rate, use standard deviation directly
                stability_components.append(weight * analysis[metric]['std'])
            else:
                # For other metrics, use coefficient of variation
                stability_components.append(
                    weight * analysis[metric]['coefficient_of_variation']
                )
        
        analysis['overall_stability_score'] = sum(stability_components)
        
        return analysis

    def print_stability_analysis(self, analysis: Dict) -> None:
        """Pretty print the stability analysis results."""
        print("\nStability Analysis Results")
        print("=" * 50)
        
        print("\nSuccess Rate Statistics:")
        print(f"Mean: {analysis['success_rate']['mean']:.2%}")
        print(f"Standard Deviation: {analysis['success_rate']['std']:.2%}")
        
        metrics = ['years_survived', 'final_population', 'final_resources', 
                  'final_health', 'distance_covered']
        
        for metric in metrics:
            print(f"\n{metric.replace('_', ' ').title()} Statistics:")
            print(f"Mean: {analysis[metric]['mean']:.2f}")
            print(f"Standard Deviation: {analysis[metric]['std']:.2f}")
            print(f"Coefficient of Variation: {analysis[metric]['coefficient_of_variation']:.2%}")
        
        print("\nOverall Stability Score:", f"{analysis['overall_stability_score']:.4f}")
        print("(Lower score indicates more stable configuration)")

# Generation Ship Configurations with Balanced Challenges

configurations = {
    "steady_pressure": {
        "initial_population": 1000,     
        "ship_capacity": 1100,          
        "initial_resources": 110000,    
        "birth_rate": 9.4,              
        "death_rate": 3.7,               
        "resource_gen_rate": 99.7,        
        "lightspeed_fraction": 0.0059,
        "health_index": 100
    },
    "overcrowding_risk": {
        "initial_population": 1000,     
        "ship_capacity": 1100,          
        "initial_resources": 110000,    
        "birth_rate": 9.4,              
        "death_rate": 3.7,               
        "resource_gen_rate": 100.5,        
        "lightspeed_fraction": 0.0059,
        "health_index": 100
    },
        "overcrowding_risk_2": {
        "initial_population": 1000,     
        "ship_capacity": 1050,          
        "initial_resources": 110000,    
        "birth_rate": 9.4,              
        "death_rate": 3.7,               
        "resource_gen_rate": 103.5,        
        "lightspeed_fraction": 0.0059,
        "health_index": 100
    }
}


class ShipWeightOptimizer:
    def __init__(self):
        self.client = StabilityAnalysisClient()
        
    def evaluate_configuration(self, capacity, resources, resource_gen_rate, num_runs=50):
        config = {
            "initial_population": 1000,  # Fixed initial population
            "ship_capacity": capacity,
            "initial_resources": resources,
            "birth_rate": 9.4,              
            "death_rate": 3.7,               
            "resource_gen_rate": resource_gen_rate,        
            "lightspeed_fraction": 0.0059,
            "health_index": 100
        }
        
        # Run stability analysis
        stability = self.client.analyze_stability(config, num_runs)
        
        # Calculate efficiency metrics
        ship_weight = capacity * 100 + resources  # Unit weight for capacity and resources
        
        return {
            'config': config,
            'ship_weight': ship_weight,
            'final_population_mean': stability['final_population']['mean'],
            'final_population_std': stability['final_population']['std'],
            'population_efficiency': stability['final_population']['mean'] / ship_weight,
            'years_survived_mean': stability['years_survived']['mean']
        }

def run_optimization():
    # Parameter ranges (as before)
    capacities = np.linspace(1000, 1500, 6)
    resources = np.linspace(80000, 120000, 6)
    resource_gen_rates = np.linspace(95, 105, 6)
    
    optimizer = ShipWeightOptimizer()
    results = []
    
    # Sequential evaluation instead of parallel
    for capacity, resources, resource_gen_rate in itertools.product(
        capacities, resources, resource_gen_rates
    ):
        try:
            result = optimizer.evaluate_configuration(
                capacity, resources, resource_gen_rate
            )
            result['params'] = (capacity, resources, resource_gen_rate)
            results.append(result)
        except Exception as e:
            print(f"Error with params ({capacity}, {resources}, {resource_gen_rate}): {str(e)}")
            continue
    
    return pd.DataFrame(results)
# Run the optimization
results_df = run_optimization()

# Sort by population efficiency (final population / ship weight)
top_configs = results_df.nlargest(5, 'population_efficiency')
print("\nTop 5 Most Efficient Configurations:")
print(top_configs[['config', 'final_population_mean', 'ship_weight', 'population_efficiency']])

# Analyze parameter relationships
correlation_matrix = results_df[[
    'ship_weight', 'final_population_mean', 'years_survived_mean',
    'params'
]].apply(lambda x: pd.Series({
    'capacity': x['params'][0],
    'resources': x['params'][1],
    'resource_gen_rate': x['params'][2]
}))

print("\nParameter Correlations:")
print(correlation_matrix.corr())